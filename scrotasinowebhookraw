--[[DI BAWAH INI JANGAN DI EDIT!!!]]--
nl = "\n"
function mf(n)
  return math.floor(n/32)
end
worlds = {}
start = startFrom
ends = #worldList
aa = os.time()
for i = start, ends do
 table.insert(worlds, worldList[i])
end
function main()
  for _,list in pairs(worlds) do

function takeP()
   for _,tile in pairs(getTiles()) do
      if tile.fg == PickaxePos or tile.bg == PickaxePos then
         findPath(tile.x,tile.y) 
         sleep(1000)
         collectSet(true,2)
         sleep(500)
         collectSet(false,2)
         if findItem(98) > 0 then
            break
         end
      end
   end
end

function dropPick()
    sendPacket(2, "action|drop\n|itemID|" .. 98)
    sendPacket(2, "action|dialog_return\ndialog_name|drop_item\nitemID|" .. 98 .. "|\ncount|" .. findItem(98) - 1)
    sleep(1000)
end

function PickaxeControl()
    if TakePickaxe == "yes" and findItem(98) == 0 then
        warp(PickaxeWorld,PickaxeWorldID)
        sleep(500)
        takeP()
        sleep(3000)
        if findItem(98) > 0 then
            wear(98)
            sleep(2000)
            dropPick()
            sleep(1000)
            if findItem(98) > 1 then
                warp(PickaxeWorld,PickaxeWorldID)
                dropPick()
                sleep(1000)
            end
        else
            while findItem(98) == 0 do
                sleep(5000)
                warp(PickaxeWorld,PickaxeWorldID)
                sleep(500)
                takeP()
                sleep(3000)
                if findItem(98) > 0 then
                    wear(98)
                    sleep(2000)
                    dropPick()
                    sleep(1000)
                    if findItem(98) > 1 then
                        warp(PickaxeWorld,PickaxeWorldID)
                        dropPick()
                        sleep(1000)
                    end
                end
            end
        end
    end
    if findItem(98) > 1 then
        warp(PickaxeWorld,PickaxeWorldID)
        dropPick()
        sleep(1000)
    end
end

function warp(world,id)
    sendPacket(3, "action|join_request\nname|"..string.upper(world).. "\ninvitedWorld|0") 
    sleep(5000)
    sendPacket(3, "action|join_request\nname|" .. string.upper(world) .. "|" .. string.upper(id).. "\ninvitedWorld|0") 
    sleep(5000)
end

function recon(worldzz, dooridzz, xx, yy)
 if getBot().captcha == "Couldn't solve" then
    disconnect()
    sleep(10000)
    connect()
    if getBot().status == "online" then
      sleep(3000)
      warp(worldzz ,dooridzz) 
      sleep(2000)
      findPath(xx,yy) 
      sleep(1000)
    end
end
while getBot().status == "online" and getTile(math.floor(getBot().x/32),math.floor(getBot().y/32)).fg == 6 do
   sleep(3000)   
   warp(worldzz ,dooridzz) 
   sleep(1000)
   findPath( xx, yy)
   sleep(300)
end
  while getBot().status ~= "online" do
      connect() 
      sleep(10000)
      if getBot().status == "online" then
          sleep(3000)
          warp(worldzz ,dooridzz) 
          sleep(2000)
          findPath(xx,yy) 
          sleep(1000)
      end
   end
end

function setPos(a1,b1)
  findPath((a1),(b1))  
  sleep(1000)
  pnb() 
  sleep(500)
end

function pnb5()
    collectSet(true,3)
    place(blockId,-1,-2)
    sleep(DelayPlace)
    place(blockId,-1,-1)
    sleep(DelayPlace)
    place(blockId,-1,0)
    sleep(DelayPlace)
    place(blockId,-1,1)
    sleep(DelayPlace)
    place(blockId,-1,2)
    sleep(DelayPlace)
  for i = 1,hit,1 do
      punch(-1,-2)
      sleep(DelayPunch)
      punch(-1,-1)
      sleep(DelayPunch)
      punch(-1,0)
      sleep(DelayPunch)
      punch(-1,1)
      sleep(DelayPunch)
      punch(-1,2)
      sleep(DelayPunch)
   end
   sleep(50)
   recon(list,dooridfarm,posX,posY)
end

function pnb4()
    collectSet(true,3)
    place(blockId,-1,-2)
    sleep(DelayPlace)
    place(blockId,-1,-1)
    sleep(DelayPlace)
    place(blockId,-1,0)
    sleep(DelayPlace)
    place(blockId,-1,1)
    sleep(DelayPlace)
  for i = 1,hit,1 do
      punch(-1,-2)
      sleep(DelayPunch)
      punch(-1,-1)
      sleep(DelayPunch)
      punch(-1,0)
      sleep(DelayPunch)
      punch(-1,1)
      sleep(DelayPunch)
   end
   sleep(50)
   recon(list,dooridfarm,posX, posY)
end

function pnb3()
    collectSet(true,2)
    place(blockId,-1,-1)
    sleep(DelayPlace)
    place(blockId,-1,0)
    sleep(DelayPlace)
    place(blockId,-1,1)
    sleep(DelayPlace)
  for i = 1,hit,1 do
      punch(-1,-1)
      sleep(DelayPunch)
      punch(-1,0)
      sleep(DelayPunch)
      punch(-1,1)
      sleep(DelayPunch)
   end
   sleep(50)
   recon(list,dooridfarm,posX, posY)
end

function pnb2()
    collectSet(true,2)
    place(blockId,-1,-1)
    sleep(DelayPlace)
    place(blockId,-1,0)
    sleep(DelayPlace)
  for i = 1,hit,1 do
      punch(-1,-1)
      sleep(DelayPunch)
      punch(-1,0)
      sleep(DelayPunch)
   end
   sleep(50)
   recon(list,dooridfarm,posX, posY)
end

function pnb1()
    collectSet(true,1)
    place(blockId,-1,0)
    sleep(DelayPlace)
  for i = 1,hit,1 do
      punch(-1,0)
      sleep(DelayPunch)
   end
   sleep(50)
   recon(list,dooridfarm,posX, posY)
end

function pnb()
    while findItem(blockId) > 0 do
        if findItem(seedId) >= 180 then
            collectSet(false,0)
            break
        end
	if PnbTile == 1 then
           pnb1()
	elseif PnbTile == 2 then
           pnb2()
	elseif PnbTile == 3 then
           pnb3()
	elseif PnbTile == 4 then
           pnb4()
	elseif PnbTile == 5 then
           pnb5()
        end
    end
end


function plant() 
  for _,tile in pairs(getTiles()) do
    if tile.fg ~= 0 and tile.fg ~= seedId and getTile(tile.x,tile.y - 1).fg == 0 then
      if findItem(seedId) == 0 then
        break
      end
      findPath(tile.x,tile.y - 1) 
      sleep(160)
      place(seedId,0,0) 
      sleep(DelayPlant)
      collect(2) 
      sleep(50)
      recon(list,dooridfarm,tile.x,tile.y-1)
    end
  end
end

function harvest()
    for _,tile in pairs(getTiles()) do
      if tile.fg == seedId and getTile(tile.x,tile.y).ready then
         if findItem(blockId) >= 180 then
             break
         end
         findPath(tile.x,tile.y) 
         sleep(160)
         punch(0,0) 
         sleep(DelayHarvest)
         collect(2) 
         sleep(50)
         recon(list,dooridfarm,tile.x,tile.y)
      end
   end
end


function clear()
  for _,i in ipairs(trash) do
    if findItem(i) > 0 then 
      local tresh = findItem(i)
      sendPacket(2, "action|trash\n|itemID|".. i)
      sleep(500)
      sendPacket(2, "action|dialog_return\ndialog_name|trash_item\nitemID|" .. i .. "|\ncount|" .. tresh) 
      sleep(700)
      tresh = nil
    end
  end
end

function buyi()
   while findItem(112) > packPrice do
      sendPacket(2,"action|buy\nitem|"..packName)
      sleep(3000)
      if findItem(112) < packPrice then
         break
      end
   end
end

function droppack()
   collectSet(false,0)
   warp(packWorld,dooridpack) 
   sleep(400)
   buyi()
   sleep(500)
   for _,tile in pairs(getTiles()) do
      if tile.fg == packPos or tile.bg == packPos then
         findPath(tile.x-1,tile.y) 
         sleep(1000)
         recon(packWorld,dooridpack,tile.x-1,tile.y)
         sleep(2000)
         for i=1,tiledrop do
  	    for _,ab in ipairs(packList) do
      	       while findItem(ab) ~= 0 do
      	 	  local peck = findItem(ab)
      	 	  sendPacket(2,"action|drop\n|itemID|"..ab)
      	 	  sleep(2000)
      	 	  sendPacket(2,"action|dialog_return\ndialog_name|drop_item\nitemID|"..ab.."|\ncount|" .. peck)
      	 	  sleep(2000)
      	 	  peck = nil
      	 	  move(1,0)       
                  sleep(1000)
      	       end
   	    end
         end
      end
   end
   sleep(2000)
   warp(list,dooridfarm) 
   sleep(2000)   
end

function dropseed()
   collectSet(false,0)
   warp(seedWorld,dooridseed) 
   sleep(400)
   for _,tile in pairs(getTiles()) do
      if tile.fg == seedPos or tile.bg == seedPos then
         findPath(tile.x-1,tile.y) 
         sleep(1000)
         recon(seedWorld,dooridseed,tile.x-1,tile.y)
         for i=1,tiledrop do
            while findItem(seedId) > 130 do
      	       if findItem(seedId) <= 110 then
         	  break
      	       end
      	       drop(seedId,30)
      	       sleep(2000)
               move(1,0)
               sleep(1000)
            end
         end
      end
   end
   sleep(2000)
   warp(list,dooridfarm) 
   sleep(2000)
end

function ready()
  count = 0
   for _, tile in pairs(getTiles()) do
      if tile.fg == seedId and tile.ready then
        count = count + 1
      end
    end
  return count
end

function unready()
  count = 0
   for _, tile in pairs(getTiles()) do
      if tile.fg == seedId and not tile.ready then
        count = count + 1
      end
    end
  return count
end

function fossil(id)
  local m=0
  for _,til in pairs(getTiles()) do
      if til.fg == id then 
         m = m + 1
      end
  end
  return m
end

function scanseed(id)
   local m=0
   for _,object in pairs(getObjects()) do
       if object.id==id then 
          m=m + object.count
       end
   end
   return m
end

    PickaxeControl()
    sleep(500)
    warp(list,dooridfarm) 
    sleep(500)
    repeat
      harvest() 
      sleep(100)
      setPos(posX,posY) 
      sleep(100)
      plant() 
      sleep(100)
      clear()
      sleep(100)
      if findItem(seedId) > 130 then
        dropseed()
        sleep(500)
      elseif findItem(112) > MinimumGems and KeepGems == false then
        droppack()
        sleep(500)
      elseif getBot().slots <= minimBackpack then
         sendPacket(2,"action|buy\nitem|upgrade_backpack")
         sleep(3000)
      end
      sleep(2000)
      until 
      getBot().world == list and ready(seedId) == 0
      plant(seedId) 
      sleep(200)
    end
end

main()
